# 4. Design Patterns

## 4.1. Généralités

Un design pattern est une architecture-type, une "organisation" de classes ou de modules 
- **pour répondre à une problématique classique** 
- **dans un contexte donné**


Les 23 design patterns historiques ont été formalisés dans les années 90 par un groupe d'experts surnommés le "Gang Of Four".

Ils ont classés les design patterns en 3 catégories : 
- patterns de structure : définissent des schémas entre classes, leur dépendance les unes aux autres, leur compatibilité

- patterns de comportement : se focalisent sur les actions-types des classes qui les composent

- patterns de création : répondent à la problématique "Comment créer tel ou tel type d'objet ?"

Aujourd'hui bon nombre de ces patterns sont intégrés dans les bibliothèques et frameworks modernes.

D'autres patterns, ayant un angle de vision + large ont vu le jour. Par exemple, le pattern MVC, l'architecture microservice, le Repository ...

Nous étudierons dans ce cours quelques patterns (pas tous !)

## 4.2. Iterator

Type : Comportemental
Principe : Retourner un par un des objets parmi un ensemble(fournir le suivant, le suivant ... jusqu'à la fin)

[Refactoring.guru](https://refactoring.guru/design-patterns/iterator)

Dans l'idéal on sépare les données : iterable de l'itérateur (iterator)
L'itérateur est caché "sous le capot" et se charge de parcourir les éléments
L'itérable est l'ensemble qui peut être parcouru séquentiellement par l'itérateur.

Une liste est un itérable, mais un itérable n'est pas toujours une liste !

Par exemple cet itérable infini répond au pattern 

```java

public class InfiniteIterable{
    private int currentValue = 1;

    public getNext(){
        currentValue +=1;
        return currentValue;
    }

    public boolean hasMore(){
        return false;
    }
}

```

### Lien entre Iterable et boucles for

Bien souvent, un itérable peut être pris en charge nativement par le langage au sein d'une boucle "forEach"

```java


[...]

for (T element : iterable){ // possible ssi iterable implémente Iterable<T>

    [...]
}


```

==> Aller voir la définition en java de Iterable<T>

En fait, une boucle forEach revient à faire :
```
while(iterable.iterator().hasNext())
{
    T element = iterable.iterable().next();
    [...]

}

```

### MEP Python

```python

class Compteur:
    def __init__(self, n):
        self.n = n
        self.i = 1

    def __iter__(self):
        return self

    def __next__(self):
        if self.i <= self.n:
            valeur = self.i
            self.i += 1
            return valeur
        else:
            raise StopIteration


c = Compteur(5)
for nombre in c:
    print(nombre)

```

Question : Dans la classe Compteur, qu'est ce qui permet à l'objet c d'etre parcouru dans une boucle for ?

Question : que se passe-t'il si l'on fait une deuxième boucle for identique à la première sur le même objet c ?




## 4.3. Observer / Observable

Intention : Définir 
- des observables, émetteurs d'évènements
- des observeurs, qui vont réagir aux évènements des "observés"

[Lien refactoring.guru](https://refactoring.guru/design-patterns/composite)



## 4.4. Composite

[Lien refactoring.guru](https://refactoring.guru/design-patterns/observer)


## 4.5. Proxy

[Lien refactoring.guru](https://refactoring.guru/design-patterns/proxy)


## 4.6. Strategy

[Lien refactoring.guru](https://refactoring.guru/design-patterns/strategy)


## 4.7. Singleton

[Lien refactoring.guru](https://refactoring.guru/design-patterns/singleton)

## 4.8. Chain of Responsibility

[Lien refactoring.guru](https://refactoring.guru/design-patterns/chain-of-responsibility)
