## 3.4. Annotations

### A quoi ca sert ?

Une annotation sert √† apporter des informations sur une classe (par sur ses instances)
C'est comme si on documentait le code source pour ajouter des informartions sur la classe, ses m√©thodes, etc...

### Quoi annoter ?

On peut annoter : 
- Une classe (ou une interface)
- Une propri√©t√©
- Une m√©thode
- Un constructeur
- Un param√®tre d'une m√©thode

### Persistence des annotations
Les annotations peuvent servir √† diff√©renntes phases :
- D√©veloppement : compl√®te la documentation, permet d'automatiser l'autocompl√©tion, d'ignorer certains avertissements du linter/check-syntax. Dans ce cas, lorsqu'on est sur un langage compil√© type java, ces annotations disparaissent dans les objets compil√©s. Elles ne sont plus lisibles au runtime

- Runtime : Si l'on souhaite que l'application lise, par introspection, les annotations pr√©sentes sur une classe et se comporte d'une fa√ßon diff√©rente.

Dans ce dernier cas l'introspection est une notion tr√®s utile.
On doit √™tre capable, au moment de l'execution, d'examiner la classe (un peu comme si on lisait un code source) pour d√©tecter les annotations pr√©sentes.

### Utilisation en java
```java
@MonAnnotation
public class MaSuperClasse{

	@MonAnnotation
	protected String unePropriete = null;
	
	@MonAnnotation
	public void uneMethode(@MonAnnotation int param1){
	...
	}
	@MonAnnotation
	public MaSuperClasse(){
	 ...
	}
	
	

}
```

==> Ici la m√™me annotation est pr√©sente √† plusieurs niveaux (classe, m√©thode, propri√©t√©, constructeur, param√®tre)
==> Nous verrons qu'il est possible de limiter l'usage d'une annotation 

### Annotations avec attributs

Les attributs sont une solution pour "sp√©cialiser" une annotation avec des cl√©s-valeurs

```java
public class MaSuperClasse{

	@MonAnnotation (attribut1 = "valeur", attribut2 = "autreValeur")
	protected String unePropriete = null;
	
	public void uneMethode(@MonAnnotation int param1){
	...
	}
	public MaSuperClasse(){
	 ...
	}
	
	

}
```
### D√©clarer sa propre annotation (toujours en java)

```java
import java.lang.annotation.*;

@Retention(RetentionPolicy.RUNTIME) // annotation disponible √† l'ex√©cution
@Target(ElementType.METHOD)         // utilisable seulement sur les m√©thodes
public @interface Info {
    String auteur();
    String date();
    int version() default 1; // valeur par d√©faut
}
```
==> Cette annotation comporte 2 attributs obligatoires et un optionnel.

On pourra donc faire, par exemple, 
```java
public class MaSuperClasse{

	@Info (auteur = "Slo", date = "29/12/1981")
	public void uneMethode(@MonAnnotation int param1){
	...
	}
}
```
ou bien 
```java
public class MaSuperClasse{

	@Info (auteur = "Slo", date = "29/12/1981" , version = 2)
	public void uneMethode(@MonAnnotation int param1){
	...
	}
}
```
### Utilisation dans les biblioth√®ques de test unitaire

Les annotations sont tr√®s utiles lorsquu'on d√©veloppe des tests unitaires avec ds frameworks type Junit.
Elles permettent d'apppoprter des infos : 
- Quelles m√©thodes sont des tests
- Comment doivent-elles initialis√©es
- Quelle m√©thode pour pr√©parer le test

```java
import org.junit.jupiter.api.*;

import static org.junit.jupiter.api.Assertions.*;

public class CalculatriceTest {

    private Calculatrice calc;

    @BeforeAll
    static void initialisationGlobale() {
        System.out.println("==> Initialisation globale avant tous les tests");
    }

    @AfterAll
    static void nettoyageGlobal() {
        System.out.println("==> Nettoyage global apr√®s tous les tests");
    }

    @BeforeEach
    void setUp() {
        System.out.println("-> Avant un test");
        calc = new Calculatrice(); // nouvel objet pour chaque test
    }

    @AfterEach
    void tearDown() {
        System.out.println("-> Apr√®s un test");
    }

    @Test
    void testAddition() {
        int resultat = calc.addition(2, 3);
        assertEquals(5, resultat, "2 + 3 devrait donner 5");
    }

    @Test
    void testDivision() {
        int resultat = calc.division(10, 2);
        assertEquals(5, resultat, "10 / 2 devrait donner 5");
    }

    @Test
    void testDivisionParZero() {
        assertThrows(IllegalArgumentException.class, () -> {
            calc.division(10, 0);
        }, "Division par z√©ro devrait lever une exception");
    }
}
```


### Dans les frameworks

Dans les frameworks type Spring, les annotations servent √† configurer l'application, c'est √† dire d√©finir quelles classes sont des composants de l'application, quelles m√©thodes d√©finissent des routes ...

Le framework, au d√©marrage de l'application, commence par scanner l'ensemble des packages et r√©alise une introspection des classes pour trouver celles qui comportent telle ou telle annotation

```java
@RestController   // indique que cette classe expose des endpoints REST
public class HelloController {

    @GetMapping("/hello")
    public String hello() {
        return "Bonjour depuis Spring Boot !";
    }

    @GetMapping("/hello/{nom}")
    public String helloNom(@PathVariable String nom) {
        return "Bonjour " + nom + " üëã";
    }
}
```


### MEP : 

Ce chapitre est essentiellement illustr√© avec le langage Java.

En utilisant notre cher ami Google, faites un travail de recherche sur les langage Python et PHP et dites moi : 

- Comment utilise t-on des annotations (quelle est la syntaxe ?)
- Peut-on d√©finir nos propres annotations
- Peut-on d√©finir des propri√©t√©s sur une annotation ?
- Quels sont les principales utilisations des annotations en python
- Quelles diff√©rences avec les annotations en java ?

