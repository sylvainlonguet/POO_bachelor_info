## 3.1. Expressions lambda

### Principe

Une expression lambda ou "fonction fléchée" est une définition rapide, anonyme d'une fonction acceptant un certain nombre de paramètres et renvoyant une valeur.

### Implémentation en Javascript
```javascript
function carre(nombre){
   return nombre * nombre;
}
```
équivaut à ...

```javascript
const carre = (nb) => nb * nb ;
```
### Implémentation en Python
```python
def carre(nombre):
   return nombre * nombre
```

équivaut à ...

```python
carre = lambda nb: nb * nb
```
### Implémentation en Java 

```java
List<String> mots = Arrays.asList("pomme", "banane", "kiwi", "cerise", "abricot");

// Tri alphabétique avec lambda
Collections.sort(mots, (a, b) -> a.compareTo(b));

// Tri par longueur avec lambda
Collections.sort(mots, (a, b) -> a.length() - b.length() );
```

**A NOTER : En java, l'expression lambda doit "matcher" en terme de signature avec une méthode du type attendu.**

Explication :
-------------

La signature de ```Collections.sort``` est :

```static <T> void Collections.sort<T>(List<T> , Comparator<? extends T>)```

=> la méthode attend une liste de T (T = type quelconque)
=> elle attend aussi un Comparateur (Comparator) de ce même type T
... C'est à dire un objet capable de comparer deux objets de meme type T et de dire lequel doit être placé avant l'autre

... si on regarde maintenant Comparator<T>, on voit que c'est une interface générique qui possède une méthode 

```java
int compare(T o1, T o2)
```
Donc, on aurait pu écrire ceci : 

```java
Comparator<String> comparator = new Comparator<>(){
   public int compare(String o1, String o2){
	return a.length() - b.length();
	}
}
	
Collections.sort(mots, ccomparator);
```
Mais on peut simplifier cela en :

```java
Collections.sort(mots, (a, b) -> a.length() - b.length() );
```

### Utilisation et limites

- Les lambdas sont utiles pour alléger le code (ne pas définir toute une fonction - voire tout une classe anonyme en java)

- Elles sont souvent utilisées en tant que paramètre dans des fonctions / méthodes natives du langage pour des opérations de 
- tri
- filtrage
- map
- consommation (forEach)
- recherche d'oocurrence (some, all)


### Cas particulier du Javascript

En javascript, l'objet this désigne l'objet courant, dans lequel le code s'éxécute

Lorsqu'on définit une fonction, le this désigne l'objet qui execute la fonction.
Il peut s'agir de l'objet window...

Lorsqu'on utilise le mot-clé this au sein d'une lambda, this désigne l'objet courant dans lequel on a défini la lambda


Exemple :
```javascript
function Personne(prenom) {
  this.prenom = prenom;

  this.afficherNomClassique = function () {
    setTimeout(function () {
      console.log("Fonction classique :", this.prenom);
    }, 1000);
  };

  this.afficherNomLambda = function () {
    setTimeout(() => {
      console.log("Lambda :", this.prenom);
    }, 1000);
  };
}

const alice = new Personne("Alice");
alice.afficherNomClassique();
alice.afficherNomLambda();



```

### Mise en pratique

Travail sur l'interface ```java.util.Comparator<T>``` et sur ```Predicate<T>```

- L'interface **java.util.Comparator<T>** a pour objectif de fournir une méthode permettant de classer 2 objets de même type T en renvoyant un nombre entier négatif ou positif en fonction de la position relative des 2 objets.

  La seule méthode à implémenter est **compare**

```int compare(T o1, T o2)```

- L'interface **Predicate<T>** permet quant à elle de renvoyer true ou false en fonction d'une méthode unique boolean test(T o)

  Elle est utilisée dans les méthodes de filtrage (removeIf, filter, all, some ...)





```java
// Jeu de test

ArrayList<String> arrayList = new ArrayList<>();
arrayList.add("22222");
arrayList.add("333333333");
arrayList.add("111");

/////////////////////

Comparator<String> comparator = new Comparator<>(){
    
    // TODO1 : Compléter afin de trier par longueur croissante
}

arrayList.sort(comparator);

// TODO2 : Remplacer le comparator par une lambda

// Filtrage
Predicate<String> predicate = new Predicate<>()
{
    
    // TODO3 : compléter pour ne garder que les éléments 
    // dont la longueur est supérieure à 5 caractères
}

List<String> filtered = arrayList.stream()
                                 .filter(predicate)
                                 .collect(Collectors.toList());

// TODO4 : Remplacer le predicate par une expression lambda 

// Test : 
for (String s : arrayList){
    System.out.println(s);
}


```



