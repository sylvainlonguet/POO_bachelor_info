# Etude du framework SPRING

## Généralités

Spring est un framework populaire en Java. Il s'agit en réalité de plusieurs librairies compatibles entre elles. On parle d'écosystème Spring

### JEE / Jakarta EE

Dans fin des années 2000, Java EE est le framework le plus utilisé par les développeurs Java. Il est basé sur les servlets (serveurs web). Une servlet est une application web déployée dans un conteneur d'application web (comme Tomcat par exemple)
JEE devient Jakarta EE en 2018 suite au rachat de Java par Oracle et la reprise du projet par la fondation Eclipse.

Certains packages sont alors renommés, par ex.
javax.servlet => jakarta.servlet

### Spring

- Framework alternatif et open-source
- Créé en 2003
- Philosophie : favoriser la **configuration** plutôt que le codage
  => Réutiliser des fonctionnalités bas-niveau
  Tout un écosystème modulaire : MVC, Data, Security, Cloud …
- Compatible JEE / Jakarta (réutilise mêmes certaines classes)

### Spring et Spring Boot

- Spring est le noyau "historique", permet notamment l'**Injection de dépendance**

- SpringBoot est une extension de Spring. Il apporte en + :
  - l'autoconfiguration
  - un serveur embarqué
  - un packaging simplifié (possibilité de générer des .jar)

### Quelques librairies Spring

| Librairie       |                Utilisation                |
| :-------------- | :---------------------------------------: |
| Spring MVC      |           API REST, controllers           |
| ThymeLeaf       |           Moteur de rendu (SSR)           |
| Spring Security | Sécurité (authent, autorisation, SSO ...) |
| Spring Data     |             Accès aux données             |
| Spring Cloud    |      Architecture distribuée / cloud      |
| Hateos          |           API auto-documentées            |
| Actuator        |                Monitoring                 |

### Les starter-packs

Les Spring Boot Starter Packs (ou simplement starters) sont des modules de dépendances préconfigurés qui facilitent l’ajout de fonctionnalités à une application Spring Boot.

ex.

```
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-web</artifactId>
</dependency>


```

Ce starter inclut automatiquement :

- Spring MVC
- Tomcat (serveur web embarqué)
- JSON (Jackson)
- et les configurations nécessaires pour créer une API REST.

### Principe de l'inversion de contrôle

Spring utilise le principe d’inversion de contrôle.
Ce n’est pas le programme principal qui appelle les librairies, mais l’inverse !

![](img/ioc.png)

Le développeur n'a qu'à placer ses classes métiers "au bon endroit" et laisser le framework les appeler au bon moment.

**Avantages**

- Se focaliser sur la logique métier et moins sur les fonctions support (sécurité, routage, accès aux bases, test …)
- Configuration plutôt que codage

**Inconvénients**

- Débuggage moins naturel
- Effet "magique", on ne maîtrise pas le déroulement de l'execution
- Nécessité d'apprendre le framework en + du langage natif

### Principe du modèle MVC

![](img/MVC_contre_ex.png)

==> MVC= Modèle - Vue - controller

### Architecture distribuée

Principe : pouvoir déployer plusieurs instances du même service en fonction de la demande (scalabilité)

![](img/architecture_distri.png)

## Prise en main de Spring

### Installation de l'environnement

Vous aurez besoin de :

- Java (dernière version ou au moins 17)
- maven
- VSCode + extensions :
  Java Extension Pack
  SpringBootTools

### Hello Spring !

https://start.spring.io

![](img/spring_initializer.png)

- Télécharger l'archive
- Modifier la classe JolMoviesApplication.java et rajouter un `System.out.println("Hello")` dans la méthode main
- Lancer l'application grâce à l'extension Spring Boot

### Notre premier endpoint

Nous allons maintenant rajouter un "endpoint" pour faire apparaître notre "hello world" dans un navigateur

- Créer un package com.lajol.jolmovies.Controllers

- Créer une classe HelloController.java :

```java
@RestController
public class HelloController {
    @GetMapping("/hello")
    public String sayHello(){
        return "Hello, from my first controller, yeah !";
    }
}

```

- Démarrer l'appli depuis l'extension Spring Boot

- Tester dans un navigateur la page http://localhost:8080/hello

## Concepts de base de Spring Boot

### Gestionnaire de dépendance

Dans notre cas : **maven**
Permet :

- d’automatiser la récupération des dépendances du projet
- De gérer le versionning de l’artefact (notre application)
- Donner des directives de build
- Fichier pom.xml
- Alternatives : gradle

Dans d’autres langages, on retrouve le même genre d’utilitaire :

- Npm ou yarn en JS / Node
- Pip ou anaconda en python
- Composer en php/symfony

### Autoconfiguration

Vous remarquerez que vous n'avez pas du installer de server Apache ou Glassfish.
Principe : Spring Boot scanne les dépendances du classPath et "devine" la configuration. Exemple : serveur web, type de base de données …

Il est bien sûr malgré tout possible de personnaliser la configuration, grâce notamment aux classes de configuration

### Bean et conteneur IoC

Un "bean" est un objet Java réutilisable, possédant des méthodes et des propriétés, en général accessibles selon une certaine convention (get/set).

Spring contient un **conteneur IoC** ou **contexte**, un objet toujours actif au cours du cycle de vie de l'application et qui répertorie les beans déclarés ainsi que leur type (classe/interface)

L'intérêt de ce conteneur est de pouvoir à tout moment fournir un bean, soit d'un type connu, soit identifié par un nom

=> Injection de dépendance (vu + tard)

### le fichier de propriétés

application.properties

Ce fichier contient les propriétés de l'application :
N° de port, context-path, base de données, niveau de traces des logs …

En fonction des modules Spring utilisés, il permet de définir certains paramètres spécifiques à un module.

https://docs.spring.io/spring-boot/appendix/application-properties/index.html

### ComponentScan

![](img/JolMoviesApplication_code.png)

L'annotation **SpringBootApplication** est équivalente à l'ajout de 2 annotations :
**ComponentScan**
**EnableAutoConfiguration**

Au démarrage de l'application :

- appel de la méthode statique main() (comme pour toute application Java)
- `SpringApplication.run(JolmoviesApplication.class, args);`
- création d'un contexte d'application (= conteneur IoC)
- Comme la classe JolMoviesApplication est annotée @SpringBootApplication :
  - Recherche des configurations spécifiques (classes annotées @Configuration)
  - Autoconfiguration à défaut
  - Scan des composants (y compris les contrôleurs !)
  - Création et injection des beans (beans dépendant d'autres beans)
  - Démarrage des serveurs (si application web)

> ### A vous !
>
> Modifier le fichier .properties afin que l'appli se lance non pas sur http://localhost:8080
> mais
> http://localhost:9090/jolmovies
>
> Toutes les autres routes (actuelles et futures) doivent commencer par /jolmovies/..
> Autrement dit vous devez changer :
>
> - N° de port du server
> - Path du dispatcher servlet
>
> Pour cela n'hésitez pas à consulter la doc !
>
> https://docs.spring.io/spring-boot/appendix/application-properties/index.html
>

## Les controllers

> **Rappels**
>
> Dans le modèle MVC, la couche contrôleur est celle en charge de recevoir les demandes de l'utilisateur (requêtes) et de renvoyer dans certains cas une vue à jour,
>
> Pour une application web, cela implique de traiter une requête HTTP:
>
> - Identifier la ressource demandée (https://monappli.fr/path/to/api)
> - Récupérer les paramètres ainsi que le body
> - Contrôler le droit d'accès à la ressource
> - Renvoyer un statut (200, 402 …) / du contenu

- **@Controller** : Cette annotation indique à Spring qu'il s'agit d'un composant => sera chargé dans le conteneur IoC
  Plutôt utilisé pour fournir des vues sous forme de templates (HTML)=> sera abordé + tard (Thymeleaf)

- **@RestController** : équivaut à **@Controller** + **@ResponseBody** => @ResponseBody indique que les méthodes retournent des données brutes directement
  Est + indiqué pour fournir du contenu sans mise en forme (API REST)
  Par défaut, le contenu renvoyé est parsé en json

### Gestion des routes

Un controller peut être annoté pour traiter une partie du path
Exemple : récupérer toutes les req. vers ../actor/… :

![](img/ACtorController.png)

Chaque méthode définie dans un controller permet ensuite de traiter une ressource fille (exemple : http:// …/actor/hollywood)

![](img/ACtorController2.png)

### Méthodes (GET, POST, ...)

![](img/Methodes.png)

PutMapping, GetMapping, DeleteMapping etc ... sont équivalents à @RequestMapping + attribut method renseigné

### PathVariables

![](img/PathVariables.png)

### Paramètres de requêtes

Exemple : http:// … /actor/hollywood?max=50

![](img/paramrequete_1.png)

Variantes :
(avec paramètres optionnels)

![](img/Paramrequete_2.png)

### body de requête

Pour les requêtes autres que GET
![](img/requestbody.png)

DTO = Data Transform Objet
= objet entité "simplifié" passé en paramètre à un formulaire

=> Spring désérialise le body de la requête et crée un ActorDTO

> ### A vous !
>
> - Créer un nouveau controller pour les routes /movie/\*
> - Importer
>   - la classe de service MovieService dans le package com.lajol.jolmovies.service
>   - la classe Movie dans com.lajol.jolmovies.entity
> - Gérer les routes suivantes :
>   - GET /movie/{id} => retourne le film n° {id}
>   - GET /movie => Liste des films
>   - GET /movie?style=.. => Liste des films de genre …
>   - POST /movie => Crée un nouveau film (voir classe Movie)
>
> Tester les routes avec PostMan ou tout outil de test de votre choix
>

### Gestion des erreurs

Il est important dans une API REST de maîtriser les codes d'erreurs (statuts) renvoyés en cas d'exception.
Il existe plusieurs approches :
1/ Intercepter l'exception au niveau de la méthode
2/ Intercepter l'exception au niveau Controller
3/ Intercepter l'exception au niveau application

#### 1/ Au niveau de la méthode

![](img/erreur_1.png)

#### 2/ Au niveau controller

![](img/erreur_2.png)

#### 3/ Au niveau global (application)

![](img/erreur_3.png)

### Message d'erreur (reason)

![](img/erreur_4.png)

Par défaut, Spring ne renvoie pas le message lié à une erreur.
(Cela évite aux pirates d'avoir trop d'infos sur le fonctionnement de l'application)

Pour nos essais, nous allons rajouter ces 2 lignes dans le fichier application.properties

```
server.error.include-message=always
server.error.include-binding-errors=always
```

> ### A vous !
>
> Suite au TP précédent…
> Gérer les erreurs suivantes :
>
> - **GET /movie/{id}**
>   Si Le film n'existe pas => retourner 404 + message "le film numéro 4 n'existe pas"
> - **GET /movie?style=**
>   Le style n'existe pas retourner BAD REQUEST
> - **POST /movie**
>   Si Champ manquant OU date de production > 2025 BAD REQUEST
>   Si Titre > 100 caractères => BAD REQUEST
>

## Validation de données

### Ajout d'une dépendance

dans le fichier pom.xml :

```
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>

```

### "entité" ou DTO "validable"

![](img/validated_1.png)

### L'annotation @Valid

côté Controller

![](img/validated_2.png)

> ### A vous !
>
> Suite au TP précédent…
>
> - Gérer les erreurs d'ajout de film grâce à la validation.
> - La réponse de la requête doit comporter les raisons du refus de création du film
>
> AIDEZ-VOUS DE LA DOC. EN LIGNE !
>
> - Ajouter une propriété "référence" à Movie. Cette propriété doit être validée par une RegExp. Exemples de références valides : FR-889112 ; USA-003645 ; GB-793222
>

## Principe d'injection de dépendance

### Objectifs : 
- "Casser" la dépendance des classes de haut niveau envers les classes de plus bas niveau
- Etre capable de mocker facilement les classes de plus bas niveau.
Par exemple : tester la couche web en mockant la couche Service.

### Comment mettre en oeuvre la DI

1. Les classes doivent dépendre d'abstractions (interfaces ou classes abstraites)

2. Les classes ne doivent pas créer eux-même leurs sous-objets.
=> Injection de dépendance

2.1. Injection par le constructeur : 

```java

class MyController{

  private IService service;
  public MyController(IService service){
    this.service = service;
  }

}

```

2.2. Injection par paramètre : 

```java

class MyController{

  
  public methode1(IService service){
    service.doSomething();
  }

}

```

2.3. Injection par setter : 

```java

class MyController{

  private IService service;

  public void setService(IService service){
    this.service = service;
  }

}

```

### Mise en oeuvre avec Spring

Spring démarre avec un conteneur de beans.
Il scanne les composants au démarrage et les stocke dans son conteneur.
Lorsqu'une classe a besoin d'un bean (d'une dépendance), Spring est capable de lui injecter cettee dépendance.

=> Composant "injectable" :

```java

@Component
public class MyService{

}

```

=> Composant utilisant un bean :

```java


public class MyController{

  @Autowired
  private MyService service;


}

```

### Annotations 

**@Service, @Respository, @Controller**
Ces annotations étendent l'annotation @Component, elles permettent donc d'être scannées au démarrage et injectées par la suite dans une autre classe.

**MISE EN PRATIQUE**

Utilisez l'injection de dépendance avec les annotations Service et Autowired pour injecter le service MovieService dans le controller


**@Primary**
Dans le cas où l'injection est ambigüe, permet de définir un bean comme prioritaire.
Exemple : 

```java

@Component
public class DBLogger implements ILogger{

  // logger qui ecrit en base de données
}

@Component
public class FileLogger implements ILogger{

  // logger qui ecrit dans un fichier
}

@Service
public class MyService{

  @Autowired
  private ILogger logger

  // lequel Spring doit-il choisir ? 
}

```


**@Qualifier**

Permet de nommer un bean, et d'injecter un bean "préférentiel"

```java

@Component(value = "db")
public class DBLogger implements ILogger{

  // logger qui ecrit en base de données
}

@Component(value = "file")
public class FileLogger implements ILogger{

  // logger qui ecrit dans un fichier
}

@Service
public class MyService{

  @Autowired
  @Qualifier("db")
  private ILogger logger

  // lequel Spring doit-il choisir ? 
}

```

### Utilisation des profils

Il est possible de lancer Spring  avec un **profil**.
Exemple : profil de dev; de test; de préprod etc...
En fonction du profil, certains composants seront visibles par Spring, d'autres non 

- Dans la commande de lancement java
```
java -jar mon_app.jar -Dspring.profiles.active=dev
```

- Grâce à une variable d'anvironnement : 
```
set SPRING_FROFILES_ACTIVE=dev
```

- Grâce au fichier de config
application.properties :

```
spring.profiles.active=dev
```

**Annotation des composants**
Pour qu'un composant ne soit visible que sur un profil donnné :

```java

@Component
@Profile("dev")
public class MyService {

}

```

> A VOUS DE JOUER !
>
> - Extraire la classe *MovieService* dans une interface *IMovieService*
> (Aidez-vous des outils de refactoring de VSCode)
> - Renommer *MovieService* en *MovieService1* 
> - Copier la classe *MovieService1* en *MovieService2*
> - Faites en sorte que *MovieController* dépende de l'interface *IMovieService*
>
> Quelle est l'erreur levée par Spring au démarrage ?
> Comment la résoudre ?

## THYMELEAF

Thymeleaf est un moteur de rendu. Il permet de faire du SSR (server-side rendering - par opposition au CSR=Client-side rendering)

Le principe : A l'image d'autres frameworks comme twig, il permet de produire des contenus HTML en s'appuyant sur des templates.

### Dépendance à ajouter

Dans pom.xml, nous aurons besoin de la dépendance suivante : 

```
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-thymeleaf </artifactId>
</dependency>


```

### Template

Par défaut, le moteur de rendu va chercher les templates dans
/resources/templates

=> Créer un fichier /resources/templates/home.html
(et mettre une page web toute simple "Hello"...)

### Controller web

Créer un nouveau controller : HomeController

```java
@Controller
public class HomeController{

   @GetMapping(value="/home")
   public String displayHomePage(){
       return "home.html";

   }

}



```

> **MISE EN PRATIQUE**
>
> Ajouter une homepage comme dans l'exemple ci-dessus
>

### Injecter des données dans le template

```java
@Controller
public class HomeController{

   @GetMapping(value="/home")
   public String displayHomePage(Model model){
       model.addAttribute("prenom", "Sylvain")
       return "home.html";

   }

}

```


```html
<body>
    <h1 th:text = "'Bonjour ' + $prenom">
    </h1>


</body>

```

### Balises spéciales

Toutes les balises <th:***> sont interprétées par Thymeleaf
Les principales sont 
- th:text

- th:each exemple : <th:each = "element : ${movies}"/>

- th-if 

- th:ref

- th:src

- th:fragment

- th:include

- th:insert

  

> **A VOUS DE JOUER :** 
> Créer une home page affichant la liste des films disponibles
> Pour chaque film, afficher un lien permettant de rediriger vers une nouvelle page avec le détail du film en question

## TESTS

### Dépendances

Nous allons utiliser deux librairies de test : 
- JUnit : outil de test historique de Java
- Mockito : permet de créer facilement des mocks sur des services, des repositories, etc...
```

<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-test</artifactId>
  <scope>test</scope>
</dependency>

<dependency>
  <groupId>org.mockito</groupId>
  <artifactId>mockito-core</artifactId>
  <scope>test</scope>
</dependency>


```
### Exemple simple avec  Junit

```
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class MyServiceTest {

    @Test
    void testAdd() {
        // Arrange
        MyService service = new CalculatorService();

        // Act
        int result = service.add(2, 3);

        // Assert
        assertEquals(5, result);
    }
}

```

Limite : lorsque le service dépend d'autres services ou de repositories, le test revient à tester les méthodes de la classe MyService, mais aussi toutes les méthodes appelées dans les classes dépendantes de MyyService


### Test unitaire d'un service

Dans cet exemple nous allons tester les méthodes d'une classe de service, qui elle-même dépend d'un Repository.
L'objectif du test est de ne tester QUE la couche Service, sans les appels aux dépendances.
Nous allons donc bouchonner la classe Repository avec Mockito


```java

@Service
public class UserService {

    @Autowired
    private final UserRepository repository;


    public String getUserName(long id) {
        User user = repository.findById(id);
        return user != null ? user.getName() : null;
    }
}

// CLASSE DE TEST : 
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

@ExtendWith(MockitoExtension.class)
class UserServiceTest {

    // Repository à mocker
    @Mock
    UserRepository repository;

    // Service dans lequel le mock doit être injecté
    @InjectMocks
    UserService service;

    @Test
    void testGetUserName() {
        // Arrange
        when(repository.findById(1L)).thenReturn(new User(1L, "Alice"));

        // Act
        String result = service.getUserName(1L);

        // Assert
        assertEquals("Alice", result);

        // Optionnel : permet de vérifier quela méthode findById a bien été appelée avec le paramètre 1L
        verify(repository).findById(1L);
    }
}


```

### Test d'un controller

exemple de controller à tester :
```java
@RestController
@RequestMapping("/users")
public class UserController {

    private final UserService service;

    public UserController(UserService service) {
        this.service = service;
    }

    @GetMapping("/{id}")
    public ResponseEntity<UserDto> getUser(@PathVariable long id) {
        UserDto user = service.getUserById(id);

        if (user == null) {
            return ResponseEntity.notFound().build();
        }

        return ResponseEntity.ok(user);
    }
}


```

Pour tester le controller, on a besoin de charger une partie du contexte Spring Boot. On a également besoin d'un client léger, capable d'executer la requête et d'analyser la réponse: il s'agit de l'objet MockMvc.

```java
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;

import static org.mockito.Mockito.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@WebMvcTest(UserController.class)
class UserControllerTest {

    // Notre client léger pour tester les routes
    @Autowired
    private MockMvc mockMvc;

    // le service à mocker
    @MockBean
    private UserService service;

    @Test
    void testGetUser_found() throws Exception {
        // Mock du service
        UserDto user = new UserDto(1L, "Alice");
        when(service.getUserById(1L)).thenReturn(user);

        mockMvc.perform(get("/users/1"))
                .andExpect(status().isOk()) // statut 2xx
                .andExpect(content().contentType(MediaType.APPLICATION_JSON))
                .andExpect(jsonPath("$.id").value(1))
                .andExpect(jsonPath("$.name").value("Alice"));

        verify(service).getUserById(1L);
    }

    @Test
    void testGetUser_notFound() throws Exception {
        when(service.getUserById(999L)).thenReturn(null);

        mockMvc.perform(get("/users/999"))
                .andExpect(status().isNotFound());

        verify(service).getUserById(999L);
    }
}


```

## SpringBootTest

Parfois, on a besoin de tester un scénario complet en chargeant l'environnement complet de Spring (les injections de dépendances, la couche Security, la couche Data)
On est alors plutôt sur des tests d'intégration.
Pour indiquer à Junit de charger l'environnement complet de SpringBoot, on utilise alors l'annotation @SpringBootTest

**Attention c'est lent**

```java

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class FullAppTest {

    @Autowired
    TestRestTemplate rest;

    @Test
    void testRealHttpCall() {
        ResponseEntity<String> response = rest.getForEntity("/hello", String.class);
        assertEquals(HttpStatus.OK, response.getStatusCode());
    }
}

```

## MEP

> A vous ! 
>
> **Dans un permier temps**
> 
> Créer une classe MovieRepository annotée @Repository 
> Cette classe jouera le rôle de fournisseur de données ... en dur pour l'instant (liste statique). Par la suite, lorsque nous implémenterons la couche Data, ce Repository ira chercher les données en base.
> L'interface IMovieService ainsi que ses implémentations doivent dépendre de ce Repository
>
> **TESTS** 
> 
> En vous inspirant des exemples ci-dessus, 
> - Tester la couche Service en mockant la partie Repository
> - Tester la couche Controller en mockant la partie Service

# SPRING DATA

## Généralités

Il est possible d'interroger directement une base SQL dans le langage de l'application.
En général, il suffit de déclarer une chaîne de caractères contenant la requête SQL et de l'envoyer à la librairie gérant la connexion à la base de données...

```java
String query = "SELECT customer.id, customer.name FROM customer WHERE customer.ville = '" + ville + "'" ;
[...]
``` 

**Problèmes**
- Failles de sécurité : notamment injection SQL. On est obligé de "nettoyer" (sanitize) les paramètres avant de les concaténer avec une requête SQL.

- Risque accru d'erreurs : Aucun check syntax sur les requêtes SQL. La récupération des résultats des requêtes dépend des champs demandés.
ex.
```java

ResultSet resultSet;
[...]

String customerName = resultSet.getString("name"); // Aucune vérification ici
```

- Redondance de code : 
Réutilisation de plusieurs requêtes SQL qui font 

- Mélange des langages (et donc des compétences) : Java (langage Objet) + SQL 

- Perte en lisibilité de code

- Dépendance vis-à-vis du langage de base de données : 
Même si le langage SQL est normé, il existe quelques subtilités entre les fonctions PostGre et Oracle (par exemple).
De même, l'écriture de requêtes SQL en Java empêche toute évolution future vers des technologies No-SQL

## Principe des ORM

O.R.M = Object Relational Mapping
Permettre une abstraction des données relationnnelles dans le paradigme Objet

- les tables deviennent des classes **Entités**
- les enregistremments deviennent des instances d'objet
- les champs d'une table deviennent les propriétés des classes

## Quelques ORM

Java propose historiquement l'ORM **Hibernate**
Les autres technos ne sont évidemment pas en reste : 
PHP => Laravel, Doctrine
Python => Django ORM
Node.js => Sequelize
C# => Entity
[...] 

## JDBC et connexion à une base

Java propose nativement une bibliothèque permettant de se connecter à une base : JDBC
JDBC = Java Database Connectivity
Elle s'adapte au driver de la bdd (MySQL) et propose une interface commune

Dépendence Maven : 
```xml
<dependency>
<groupId>mysql</groupId>
<artifactId>mysql-connector-java</artifactId>
</dependency>

```

### Connexion

```java

try{
  connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/ma_bdd" , "root" , "admin123");
}
catch (Exception e){
  e.printStackTrace();
}

```

### Lancement d'une requête

```java
String sql = "SELECT * FROM customer";
Statement statement = null;
try{
  statement = connection.createStatement();
  ResultsSet resultSet = statement.executeQuery(sql);
}
catch (Exception e){
  [...]
}

```

### Lecture des résultats

```java
String sql = "SELECT * FROM customer";
Statement statement = null;
try{
  statement = connection.createStatement();
  ResultsSet resultSet = statement.executeQuery(sql);
  while (resultSet.next()){
    int id = resultSet.getInt("id");
    String name = resultSet.getString("name");
    
  }


}
catch (Exception e){
  [...]
}

```

### Gestion des transactions

```java

connection.commit();

[...]

connection.rollback();
```


## Spring Data JPA

JDBC (bas niveau) < JPA (ORM Hibernate) < Spring Data JPA

JPA = **J**ava **P**ersistence **A**PI : il s'agit d'une interface. Sa principale implémentation est Hibernate.
Eclipse Link est une autre implémentation.
JPA utilise JDBC pour pouvoir se connecter et interroger une base, mais nous ne verrons jamais directement des classes JDBC.

Spring Data est un projet de Spring englobant les bases de données SQL et NoSQL
**Spring Data JPA** se concentre sur l'exploitation de JPA => bases de données RELATIONNELLES

### Dépendance MAVEN

```xml

<dependency>
    <groupId>com.mysql</groupId>
    <artifactId>mysql-connector-j</artifactId>
    <scope>runtime</scope>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>


```

### Configuration de la connexion

Grâce à l'autoconfiguration, un projet Spring Boot incluant les dépendances Maven de JPA + MySQL (ou autre SGBD) va tenter dès le démarrage d'obtenir une **source de données**
Il est toutefois nécessaire de configurer dans le fichier properties, les identifiants de connexion : 

```
spring.datasource.url=jdbc:mysql://127.0.0.1:3306/ma_base_de_donnees
spring.datasource.username=root
spring.datasource.password=admin123
```

Lancer l'application => Une 'datasource' est maintenant disponible

## Les entités

Les classes Entités représentent les tables de la base de données relationnelle

Ces classes ne sont pas supposées comporter des méthodes complexes ou des propriétés autres que les champs de la table concernée.

### Exemple simple

```java
@Entity
@Table(name = "mymovie")
public class Movie {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "movieId")
    private Integer id;

    private String title;
}


```
- Annotation @Entity : permet à Spring Data JPA de scanner cette classe et de la traiter comme une entitéé
- Annotation @Table : optionnel. Permet d'établir la correspondance entre nom de la table et nom de la classe SI DIFFERENTS
- Annotation @Id : Permet de définiir un champ comme clé primaire
- Annotation @GeneratedValue : Permet d'indiquer que cette valeur est générée par le SGBD. Ici par auto-incrément.
- Annotation @Column : Permet de préciser le nom de la table dans le SGBD si le nom est différent de celui de la propriété en Java. Permet aussi de préciser des propriétés du champ telles que la taille, l'autorisation du NULL ...

**Remarque**
Une propriété nommée "movieId" sera considérée comme liée au champ de BD "movie_id" (camel case => snake case)

### Relations 1-1 , 1-N

Un ORM permet aussi d'établir les relations entre entités.
Cela permet de pouvoir naviguer en java d'un objet entités aux autres objets liés.  

```java

@Entity
@Table(name = "mymovie")
public class Movie {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "movieIid")
    private Integer id;

    private String title;

    @OneToOne
    @JoinColumn(name = "fichetec_id")
    private FicheTechnique ficheTechnique;

    // Style associé au film
    @ManyToOne
    @JoinColumn(name = "style_id")
    private Style style;
}

```

Cela necessite qu'une entité Style existe, avec une clé primaire (@Id)
JPA est alors capable de faire la jointure pour atteindre l'enregistrement de 'style' lié à l'enregistrement courant de 'movie'

```java
@Entity
@Table(name = "mymovie")
public class Movie {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "movieIid")
    private Integer id;

    private String title;

    // Style associé au film
    @ManyToOne
    @JoinColumn(name = "style_id")
    private Style style;

    // Commentaires recus pour ce film
    @OneToMany(mappedBy = "movie" , cascade = CascadeType.ALL)
    private List<MovieReview> reviews;
}

@Entity
public class MovieReview {

  @Id
  private Long id;

  @ManyToOne
  @JoinColumn(name = "movie_id")
  Movie movie;
}
```

### Relations N-N

```java
@Entity
@Table(name = "mymovie")
public class Movie {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "movieIid")
    private Integer id;

    private String title;

    // Style associé au film
    @ManyToOne
    @JoinColumn(name = "style_id")
    private Style style;

    // Commentaires recus pour ce film
    @OneToMany(mappedBy = "movie" , cascade = CascadeType.ALL)
    private List<MovieReview> reviews;

    // Liste (unique) des acteurs
    @ManyToMany
    @JoinTable(name = "role_movies" , 
        joinColumns = @JoinColumn(name = "movie_id") , 
        inverseJoinColumns = @JoinColumn(name = "actor_id")
        )
    private Set<Actor> actors;
}

@Entity
public class Actor {
  @Id
  private Long id;

  @ManyToMany(mappedBy = "actors")
  private Set<Movie> movies;
}


```

### Lazy-load / Eager-load

Par défaut, lorsqu'une relation 1-N, 1-1 ou N-N existe sur une entité, l'ORM récupère l'entité SANS sa relation.
Ce n'est qu'en appelant explicitement la propriété via le getter (ex. ```movie.getActors()```) qu'une requête complémentaire est lancée
=> Cela évite de charger toute la base de données  à la première requête si les relations ont été matérialisées dans les entités !

Néanmoins il est possible d'indiquer à JPA que la / les entités complémentaires doivent être chargées dès le début via une jointure (OUTER JOIN)

```java

// Style associé au film
    @ManyToOne
    @JoinColumn(name = "style_id", fetch = FetchType.EAGER)
    private Style style;

```

Comment ca marche ?
A l'execution, JPA créée un Proxy dynamique pour conserver en cache les entités liées 


## A VOUS ! 

Créer les entités suivantes, avec les relations adéquates :
```
movie (movie_id, title , production_year , #style_id, reference, #produced_by)
style (style_id, style_name)
actor(actor_id, last_name, first_name, birthdate)
role(role_id, #actor_id , #movie_id , role )
productor(productor_id, name)
customer(customer_id, name)
borrow(borrow_id , date, #customer_id, #movie_id, status)

```

## Création du schéma en automatique

Il est possible d'indiquer à Spring de créer le schéma à partir des entités définies en java

dans le fichier properties : 
```
spring.jpa.hibernate.ddl-auto=create
```

## LES REPOSITORIES

Repositories = Classes de service permettant de lire / écrire des entités
"persister"

Spring Data JPA propose plusieurs interfaces prêtes à l'emploi : 

- CrudRepository<T,K> : permet de faire les principales opérations du CRUD
Il s'agit d'une interface générique, dépendant de 
   - T : type d'entité manipulée (ex. Movie)
   - K : Type de la clé primaire (Long)
```java 
public interface MovieRepository implements CrudRepository<Movie, Long> {

}

// Utilisation 
@Service
public class MyService{

  @Autowired
  private MovieRepository movieRepository;

  public void uneMethode(){

    movieRepository.save(aNewMovie); // persiste une entité
    movieRepository.delete (anotherMovie); // supprime
    List<Movie> movies = movieRepository.findAll();
    movieRepository.findById(15L);
    [...]


  }
}

```

!! Vous remarquerez qu'aucune méthode n'a été impplémentée dans MovieRepository.
Spring a créé une implémentation pour nous. Nous avons simplement besoin d'injecter le repository en tant qu'interface, Spring se charge du reste ...

- PagingAndSortingRepository<T,K> :
Il s'agit d'une extension de CrudRepository permettant de gérer en plus la pagination 

Prenons l'exemple d'un controller permettant de recevoir des poaramètres GET avec les éléments de pagination : 


```java

@GetMapping
public Page<Movie> getMovies
(@RequestParam(defaultValue = "0") int page , 
@RequestParam(defaultValue = "10") int size , 
@RequestParam(defaultValue = "movie_id") String sort 
){

  Pageable pageable = PageRequest.of(page, size, Sort.by(sort)); // construction d'un objet Pageable
  return movieRepository.findAll(pageable);
}

```


- JpaRepository
Etend PagingAndSortingRepository avec des méthodes permettant de traiter des enreistrements en lots et permet d'utiliser des **query methods**

Le simple fait de nommmer une méthode d'une certaine façon indique à Spring Data JPA quelle requête il doit lancer : 

ex.

```java
public interface AdvancedMovieRepository implements JPARepository<Movie, Long>{

  // Query methods
   List<Movie> findByProductionYearAndName(int productionYYear , String name);
   List<Movie> findByProductionYearLessThan(int year);
   List<Movie> findByTitleStartingBy(String beginning);


}

```

cf doc complète : 
https://docs.spring.io/spring-data/jpa/reference/jpa/query-methods.html

### Requêtes personnalisées

Par défaut l'annotation @Query accepte du JPQL (= sorte de SQL - objet)

```java
public interface AdvancedMovieRepository implements JPARepository<Movie, Long>{

  @Query("SELECT m FROM movie m WHERE m.movie_id IN (20,30,40)")
  List<Movie> getSpecialMovies();



}

```

Il est possible toutefois d'écrire une requête en SQL, en précisant nativeQuery = true

```java
public interface AdvancedMovieRepository implements JPARepository<Movie, Long>{

  @Query("SELECT * FROM movie m WHERE m.movie_id IN (20,30,40)", nativeQuery = true)
  List<Movie> getSpecialMovies();



}

```

### Requêtes personnalisées avec paramètres


```java
public interface AdvancedMovieRepository implements JPARepository<Movie, Long>{

  @Query("SELECT m FROM movie m WHERE m.title LIKE ?1 AND productionYear < ?2 ")
  List<Movie> getSpecialMovies(String title, Integer yearLimit);



}

```

Alternative : 

```java
public interface AdvancedMovieRepository implements JPARepository<Movie, Long>{

  @Query("SELECT m FROM movie m WHERE m.title LIKE :name AND productionYear < :year ")
  List<Movie> getSpecialMovies(@Param ("name") String title, @Param("year") Integer yearLimit);



}

```




## Mise en pratique

Implémenter les repositories MovieRepository, ActorRepository et CustomerRepository
Vous devez être capables de récupérer : 
- les films par libellé de genre (ex. tous les films dont le style est 'SF')
- les films empruntés par une personne dont on a l'Id
- la liste des acteurs ayant joué dans un film (on connait l'id du film)
- la liste des personnes ayant emprunté au moins un film, avec pagination

## Gestion des transactions

Par défaut, chaque appel à une méthode de repository engendre une nouvelle transaction.
Dans certains cas il peut être interessant de réaliser plusieurs opérations au sein d'une même transaction 
Il existe pour cela l'annotation @Transactional
```java

@Service
public class MyService

  @Transactional
  public void doBigStuff(){

    myRepo1.save(...);
    myRepo2.delet(...);



  }
```

L'annotation @Transactional suffit, mais il est possible de préciser le comportement à adopter si une transaction est déjà en cours : 

Créer une nouvelle transaction dans tous les cas ?
Rejoindre la transaction en cours ?
Créer une sous-transaction ? (selon compatibilité des SGBD)
cf doc complète : 
https://www.baeldung.com/spring-transactional-propagation-isolation





