# Etude du framework SPRING

## Généralités

Spring est un framework populaire en Java. Il s'agit en réalité de plusieurs librairies compatibles entre elles. On parle d'écosystème Spring

### JEE / Jakarta EE

Dans fin des années 2000, Java EE est le framework le plus utilisé par les développeurs Java. Il est basé sur les servlets (serveurs web). Une servlet est une application web déployée dans un conteneur d'application web (comme Tomcat par exemple)
JEE devient Jakarta EE en 2018 suite au rachat de Java par Oracle et la reprise du projet par la fondation Eclipse.

Certains packages sont alors renommés, par ex.
javax.servlet => jakarta.servlet

### Spring

- Framework alternatif et open-source
- Créé en 2003
- Philosophie : favoriser la **configuration** plutôt que le codage
  => Réutiliser des fonctionnalités bas-niveau
  Tout un écosystème modulaire : MVC, Data, Security, Cloud …
- Compatible JEE / Jakarta (réutilise mêmes certaines classes)

### Spring et Spring Boot

- Spring est le noyau "historique", permet notamment l'**Injection de dépendance**

- SpringBoot est une extension de Spring. Il apporte en + :
  - l'autoconfiguration
  - un serveur embarqué
  - un packaging simplifié (possibilité de générer des .jar)

### Quelques librairies Spring

| Librairie       |                Utilisation                |
| :-------------- | :---------------------------------------: |
| Spring MVC      |           API REST, controllers           |
| ThymeLeaf       |           Moteur de rendu (SSR)           |
| Spring Security | Sécurité (authent, autorisation, SSO ...) |
| Spring Data     |             Accès aux données             |
| Spring Cloud    |      Architecture distribuée / cloud      |
| Hateos          |           API auto-documentées            |
| Actuator        |                Monitoring                 |

### Les starter-packs

Les Spring Boot Starter Packs (ou simplement starters) sont des modules de dépendances préconfigurés qui facilitent l’ajout de fonctionnalités à une application Spring Boot.

ex.

```
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-web</artifactId>
</dependency>


```

Ce starter inclut automatiquement :

- Spring MVC
- Tomcat (serveur web embarqué)
- JSON (Jackson)
- et les configurations nécessaires pour créer une API REST.

### Principe de l'inversion de contrôle

Spring utilise le principe d’inversion de contrôle.
Ce n’est pas le programme principal qui appelle les librairies, mais l’inverse !

![](img/ioc.png)

Le développeur n'a qu'à placer ses classes métiers "au bon endroit" et laisser le framework les appeler au bon moment.

**Avantages**

- Se focaliser sur la logique métier et moins sur les fonctions support (sécurité, routage, accès aux bases, test …)
- Configuration plutôt que codage

**Inconvénients**

- Débuggage moins naturel
- Effet "magique", on ne maîtrise pas le déroulement de l'execution
- Nécessité d'apprendre le framework en + du langage natif

### Principe du modèle MVC

![](img/MVC_contre_ex.png)

==> MVC= Modèle - Vue - controller

### ARchitecture distribuée

Principe : pouvoir déployer plusieurs instances du même service en fonction de la demande (scalabilité)

![](img/architecture_distri.png)

## Prise en main de Spring

### Installation de l'environnement

Vous aurez besoin de :

- Java (dernière version ou au moins 17)
- maven
- VSCode + extensions :
  Java Extension Pack
  SpringBootTools

### Hello Spring !

https://start.spring.io

![](img/spring_initializer.png)

- Télécharger l'archive
- Modifier la classe JolMoviesApplication.java et rajouter un `System.out.println("Hello")` dans la méthode main
- Lancer l'application grâce à l'extension Spring Boot

### Notre premier endpoint

Nous allons maintenant rajouter un "endpoint" pour faire apparaître notre "hello world" dans un navigateur

- Créer un package com.lajol.jolmovies.Controllers

- Créer une classe HelloController.java :

```java
@RestController
public class HelloController {
    @GetMapping("/hello")
    public String sayHello(){
        return "Hello, from my first controller, yeah !";
    }
}

```

- Démarrer l'appli depuis l'extension Spring Boot

- Tester dans un navigateur la page http://localhost:8080/hello

## Concepts de base de Spring Boot

### Gestionnaire de dépendance

Dans notre cas : **maven**
Permet :

- d’automatiser la récupération des dépendances du projet
- De gérer le versionning de l’artefact (notre application)
- Donner des directives de build
- Fichier pom.xml
- Alternatives : gradle

Dans d’autres langages, on retrouve le même genre d’utilitaire :

- Npm ou yarn en JS / Node
- Pip ou anaconda en python
- Composer en php/symfony

### Autoconfiguration

Vous remarquerez que vous n'avez pas du installer de server Apache ou Glassfish.
Principe : Spring Boot scanne les dépendances du classPath et "devine" la configuration. Exemple : serveur web, type de base de données …

Il est bien sûr malgré tout possible de personnaliser la configuration, grâce notamment aux classes de configuration

### Bean et conteneur IoC

Un "bean" est un objet Java réutilisable, possédant des méthodes et des propriétés, en général accessibles selon une certaine convention (get/set).

Spring contient un **conteneur IoC** ou **contexte**, un objet toujours actif au cours du cycle de vie de l'application et qui répertorie les beans déclarés ainsi que leur type (classe/interface)

L'intérêt de ce conteneur est de pouvoir à tout moment fournir un bean, soit d'un type connu, soit identifié par un nom

=> Injection de dépendance (vu + tard)

### le fichier de propriétés

application.properties

Ce fichier contient les propriétés de l'application :
N° de port, context-path, base de données, niveau de traces des logs …

En fonction des modules Spring utilisés, il permet de définir certains paramètres spécifiques à un module.

https://docs.spring.io/spring-boot/appendix/application-properties/index.html

### ComponentScan

![](img/JolMoviesApplication_code.png)

L'annotation **SpringBootApplication** est équivalente à l'ajout de 2 annotations :
**ComponentScan**
**EnableAutoConfiguration**

Au démarrage de l'application :

- appel de la méthode statique main() (comme pour toute application Java)
- `SpringApplication.run(JolmoviesApplication.class, args);`
- création d'un contexte d'application (= conteneur IoC)
- Comme la classe JolMoviesApplication est annotée @SpringBootApplication :
  - Recherche des configurations spécifiques (classes annotées @Configuration)
  - Autoconfiguration à défaut
  - Scan des composants (y compris les contrôleurs !)
  - Création et injection des beans (beans dépendant d'autres beans)
  - Démarrage des serveurs (si application web)

### A vous !

Modifier le fichier .properties afin que l'appli se lance non pas sur http://localhost:8080
mais
http://localhost:9090/jolmovies

Toutes les autres routes (actuelles et futures) doivent commencer par /jolmovies/..
Autrement dit vous devez changer :

- N° de port du server
- Path du dispatcher servlet

Pour cela n'hésitez pas à consulter la doc !

https://docs.spring.io/spring-boot/appendix/application-properties/index.html

## Les controllers

> **Rappels**
>
> Dans le modèle MVC, la couche contrôleur est celle en charge de recevoir les demandes de l'utilisateur (requêtes) et de renvoyer dans certains cas une vue à jour,
>
> Pour une application web, cela implique de traiter une requête HTTP:
>
> - Identifier la ressource demandée (https://monappli.fr/path/to/api)
> - Récupérer les paramètres ainsi que le body
> - Contrôler le droit d'accès à la ressource
> - Renvoyer un statut (200, 402 …) / du contenu

- **@Controller** : Cette annotation indique à Spring qu'il s'agit d'un composant => sera chargé dans le conteneur IoC
  Plutôt utilisé pour fournir des vues sous forme de templates (HTML)=> sera abordé + tard (Thymeleaf)

- **@RestController** : équivaut à **@Controller** + **@ResponseBody** => @ResponseBody indique que les méthodes retournent des données brutes directement
  Est + indiqué pour fournir du contenu sans mise en forme (API REST)
  Par défaut, le contenu renvoyé est parsé en json

### Gestion des routes

Un controller peut être annoté pour traiter une partie du path
Exemple : récupérer toutes les req. vers ../actor/… :

![](img/ACtorController.png)

Chaque méthode définie dans un controller permet ensuite de traiter une ressource fille (exemple : http:// …/actor/hollywood)

![](img/ACtorController2.png)

### Méthodes (GET, POST, ...)

![](img/Methodes.png)

PutMapping, GetMapping, DeleteMapping etc ... sont équivalents à @RequestMapping + attribut method renseigné

### PathVariables

![](img/PathVariables.png)

### Paramètres de requêtes

Exemple : http:// … /actor/hollywood?max=50

![](img/paramrequete_1.png)

Variantes :
(avec paramètres optionnels)

![](img/Paramrequete_2.png)

### body de requête

Pour les requêtes autres que GET
![](img/requestbody.png)

DTO = Data Transform Objet
= objet entité "simplifié" passé en paramètre à un formulaire

=> Spring désérialise le body de la requête et crée un ActorDTO

### A vous !

- Créer un nouveau controller pour les routes /movie/\*
- Importer
  - la classe de service MovieService dans le package com.lajol.jolmovies.service
  - la classe Movie dans com.lajol.jolmovies.entity
- Gérer les routes suivantes :
  - GET /movie/{id} => retourne le film n° {id}
  - GET /movie => Liste des films
  - GET /movie?style=.. => Liste des films de genre …
  - POST /movie => Crée un nouveau film (voir classe Movie)

Tester les routes avec PostMan ou tout outil de test de votre choix

### Gestion des erreurs

Il est important dans une API REST de maîtriser les codes d'erreurs (statuts) renvoyés en cas d'exception.
Il existe plusieurs approches :
1/ Intercepter l'exception au niveau de la méthode
2/ Intercepter l'exception au niveau Controller
3/ Intercepter l'exception au niveau application

#### 1/ Au niveau de la méthode

![](img/erreur_1.png)

#### 2/ Au niveau controller

![](img/erreur_2.png)

#### 3/ Au niveau global (application)

![](img/erreur_3.png)

### Message d'erreur (reason)

![](img/erreur_4.png)

Par défaut, Spring ne renvoie pas le message lié à une erreur.
(Cela évite aux pirates d'avoir trop d'infos sur le fonctionnement de l'application)

Pour nos essais, nous allons rajouter ces 2 lignes dans le fichier application.properties

```
server.error.include-message=always
server.error.include-binding-errors=always
```

### A vous !

Suite au TP précédent…
Gérer les erreurs suivantes :

- **GET /movie/{id}**
  Si Le film n'existe pas => retourner 404 + message "le film numéro 4 n'existe pas"
- **GET /movie?style=**
  Le style n'existe pas retourner BAD REQUEST
- **POST /movie**
  Si Champ manquant OU date de production > 2025 BAD REQUEST
  Si Titre > 100 caractères => BAD REQUEST

**_BONUS_**
Autre route inexistante (ex. http:// … /nimportquoi):
=> Personnaliser le retour HTTP 404

## Validation de données

### Ajout d'une dépendance

dans le fichier pom.xml :

```
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>

```

### "entité" ou DTO "validable"

![](img/validated_1.png)

### L'annotation @Valid

côté Controller

![](img/validated_2.png)

### A vous !

Suite au TP précédent…

- Gérer les erreurs d'ajout de film grâce à la validation.
- La réponse de la requête doit comporter les raisons du refus de création du film

AIDEZ-VOUS DE LA DOC. EN LIGNE !

- Ajouter une propriété "référence" à Movie. Cette propriété doit être validée par une RegExp. Exemples de références valides : FR-889112 ; USA-003645 ; GB-793222
