## Polymorphisme


### polymorphisme adhoc

plusieurs implémentations d'une méthode en fonction des types de paramètres souhaités, le choix de la méthode est résolu statiquement dès la compilation (lorsqu'il y a compilation)

```java
public class MaClasse{
    
    [...]
    
    public int faireUnSuperTruc(){
        return faireUnSuperTruc("default");
    }
    
    public int faireUnSuperTruc(String parametre){
        
    }
    
}
```



### Polymorphisme d'inclusion

Redéfinition, masquage

C'est lorsqu'il y a un type apparent et un type constaté.
exemple en java : 

```java
class Soigneur{
	public void nourrir(Animal a){		
		... 
		a.getTypeNourriture() 
		...		
	}
}

class Main{
	public static void main(String[] args){
		Chat felix;
		Chien medor;
        ...
		soigneur.nourrir(felix);
		soigneur.nourrir(medor);
	}
}
```



### Polymorphisme paramétrique ou généricité

C'est lorsqu'une classe peut dépendre d'un autre type.
Dans plusieurs langages, des classes génériques existent souvent de manière native.

Exemple : en java, List<T>, Comparator<T>, Map<K,V>

==> Une liste <d'un certain type>
==> Un comparateur <pour un certain type>
==> Une map <ayant pour clés des objets de type K , et pour valeurs des objets de types V>

L'intérêt ?

En déclarant et en instanciant une liste de String
```java
List <String> liste = new ArrayList<>();
```

... je ne pourrai ajouter que des String
ilste.add(...	

L'autocomplétion m'indique que le paramèètre attendu est de type String ... puisque c'est une liste de String

De même le type retourne par liste.get(0) est forcément un String

==> En bref, les signatures des méthodes en fonction du type générique passé lors de l'instanciation de l'objet 


### Notion d'interface

Une interface ne contient pas de code.
Elle sert simplement à définir un "contrat" de ce que devront contenir les classes qui l'implémentent

### Exemples : 
En java : 
```java
// Interface
interface VehiculeElec {
    void demarrer();
    void recharger();
}

// Classe mère
class Velo {
    String marque;

    Velo(String marque) {
        this.marque = marque;
    }

    void entretenir() {
        System.out.println("Nettoyer le cadre et huiler la chaîne.");
    }
}

// Classe fille VeloElectrique
class VeloElectrique extends Velo implements VehiculeElec {
    int batterie; // en pourcentage

    VeloElectrique(String marque, int batterie) {
        super(marque);
        this.batterie = batterie;
    }

    // Méthodes de l'interface
    @Override
    public void demarrer() {
        System.out.println(marque + " démarre électriquement !");
    }

    @Override
    public void recharger() {
        batterie = 100;
        System.out.println(marque + " est rechargé !");
    }

    // Redéfinition d'une méthode de Velo
    @Override
    void entretenir() {
        super.entretenir(); // appelle le comportement de Velo
        System.out.println("Vérifier la batterie et les composants électriques.");
    }
}

// Classe Voiture qui implémente l'interface
class VoitureElec implements VehiculeElec {
    String marque;
    int batterie;

    VoitureElec(String marque, int batterie) {
        this.marque = marque;
        this.batterie = batterie;
    }

    @Override
    public void demarrer() {
        System.out.println(marque + " démarre !");
    }

    @Override
    public void recharger() {
        batterie = 100;
        System.out.println(marque + " est rechargée !");
    }
}

// Utilisation
public class Main {
    public static void main(String[] args) {
        VeloElectrique ve = new VeloElectrique("E-Bike", 50);
        VoitureElec v = new VoitureElec("Tesla", 80);

        ve.demarrer();
        ve.recharger();
        ve.entretenir();

        System.out.println("---");

        v.demarrer();
        v.recharger();
    }
}
```

### A quoi ca sert ?

Suppposons maintenant qu'une classe PriseElectrique soit capable de recharger un Vélo électrique ou une voiture (électrique) ...

Un vélo électrique et une voiture n'ont pas grand chose en commun à part le fait qu'ils sont tous deux rechargeables sur une prise électrique.

On pourrait faire : 
```java
class PriseElectrique {
    String nom;

    PriseElectrique(String nom) {
        this.nom = nom;
    }

    
    void brancherVelo(VeloElec velo) {
        System.out.println("Branchement sur la prise " + nom);
        velo.recharger();
        System.out.println("Recharge terminée pour le velo !");
    }
	
	void brancherVoiture(VoitureElec v) {
        System.out.println("Branchement sur la prise " + nom);
        v.recharger();
        System.out.println("Recharge terminée pour la voiture !");
    }
}
```
==> Mais pour éviter la redondance de code, on va faire plutôt : 

```java
class PriseElectrique {
    String nom;

    PriseElectrique(String nom) {
        this.nom = nom;
    }

    // Méthode pour recharger un véhicule elec (voiture ou velo)
    void brancher(VehiculeElec vehicule) {
        System.out.println("Branchement sur la prise " + nom);
        vehicule.recharger();
        System.out.println("Recharge terminée pour le véhicule !");
    }
}
```

**IMPORTANT : **
Dans la classe ```PriseElectrique```, il n'y a aucune dépendance aux classes ```VeloElec``` ou ```VoitureElec```
... simplement à l'interface VehiculeElec

La classe ```PriseElectrique``` se moque de savoir si elle recharge un vélo ou une voiture.
Elle a juste besoin de savoir qu'elle recharge un objet "répondant au contrat" "VehiculeElec"

